运行环境：python 3.5
博客地址：http://www.cnblogs.com/nigel-woo/p/5538671.html

TypeChecker：
        做了一个装饰器来检查入参是否是限定的类型，否则打印非正确。因为本次作业中所有编程题都对入参的类型有要求，就统一如此来做。
		主要运用了partial，map，any等内置函数来优雅地实现。

exercise1:
	本题在注释中简述了每种参数，注释下面是参数调用示例。

exercise2:
	做法1：通过遍历传入的字符串的每个元素，直接对其进行isdigit，isalpha，isspace调用判断类型并计数。
	做法2：通过正则表达式直接得出数字，字母，空格类型的个数，其他则通过总长度减去已得数量获得。
	
exercise3:
	本题直接通过调用len函数来判断长度是否大于5，因为限定的传入类型都可以这么判断。
	
exercise4:
	本题在求解中将传入对象的每个元素作为整体看待，不考虑其包含嵌套的列表等，否则需要通过递归来实现。
	做法1：遍历传入对象的每个元素，判断其是否在定义好的空元素列表中。
	做法2：遍历定义好的空元素列表中的元素，判断是否在传入的对象中。 主要使用了lambda，map，any等功能来优雅地实现。
	
exercise5：
	做法1：直接通过python的切片方式返回前二元素。
	做法2：通过删除切片第二个以后的元素实现。
	因为python的切片是可以超过列表限制的，所以是否判断长度超过二结果并没有区别，因此我没有判断长度。
	
exercise6:
	做法1：通过python步长为2的切片方式返回。
	做法2: 使用enumerate调用传入的列表，返回次序取2余数非零的元素组成新列表。
	做法3：思路同上，但是使用列表推导的形式，更优雅且性能更优。
	
exercise7：
	做法1：遍历传入字典的每个值，通过调用之前exercise5中方法判断是否为长度超过2的元素，组成新字典。
	做法2：思路同上，通过使用字典推导的形式，更优雅且性能更优。

exerceis8:
	做法1：通过递归的方式实现，此外因为斐波那契额的递归调用会有多次重复的调用，还加入了一个字典作为cache，把已经计算过的值储存下来，这样可以提高计算速度。
    做法2：另一种通过循环方式实现的方法，把每上一次循环计算的结果传递到下一次中，通过python独有的双值赋值，可以不需要中间变量。
	